// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package components

import (
	"errors"
	"github.com/speakeasy-sdks/hookdeck-go/v2/internal/utils"
)

type TransformationExecutorOutput2 struct {
}

type TransformationExecutorOutputBodyType string

const (
	TransformationExecutorOutputBodyTypeStr                           TransformationExecutorOutputBodyType = "str"
	TransformationExecutorOutputBodyTypeTransformationExecutorOutput2 TransformationExecutorOutputBodyType = "TransformationExecutorOutput_2"
)

type TransformationExecutorOutputBody struct {
	Str                           *string
	TransformationExecutorOutput2 *TransformationExecutorOutput2

	Type TransformationExecutorOutputBodyType
}

func CreateTransformationExecutorOutputBodyStr(str string) TransformationExecutorOutputBody {
	typ := TransformationExecutorOutputBodyTypeStr

	return TransformationExecutorOutputBody{
		Str:  &str,
		Type: typ,
	}
}

func CreateTransformationExecutorOutputBodyTransformationExecutorOutput2(transformationExecutorOutput2 TransformationExecutorOutput2) TransformationExecutorOutputBody {
	typ := TransformationExecutorOutputBodyTypeTransformationExecutorOutput2

	return TransformationExecutorOutputBody{
		TransformationExecutorOutput2: &transformationExecutorOutput2,
		Type:                          typ,
	}
}

func (u *TransformationExecutorOutputBody) UnmarshalJSON(data []byte) error {

	transformationExecutorOutput2 := TransformationExecutorOutput2{}
	if err := utils.UnmarshalJSON(data, &transformationExecutorOutput2, "", true, true); err == nil {
		u.TransformationExecutorOutput2 = &transformationExecutorOutput2
		u.Type = TransformationExecutorOutputBodyTypeTransformationExecutorOutput2
		return nil
	}

	str := ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = TransformationExecutorOutputBodyTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u TransformationExecutorOutputBody) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.TransformationExecutorOutput2 != nil {
		return utils.MarshalJSON(u.TransformationExecutorOutput2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type TransformationExecutorOutputHeadersType string

const (
	TransformationExecutorOutputHeadersTypeStr      TransformationExecutorOutputHeadersType = "str"
	TransformationExecutorOutputHeadersTypeMapOfany TransformationExecutorOutputHeadersType = "mapOfany"
)

type TransformationExecutorOutputHeaders struct {
	Str      *string
	MapOfany map[string]interface{}

	Type TransformationExecutorOutputHeadersType
}

func CreateTransformationExecutorOutputHeadersStr(str string) TransformationExecutorOutputHeaders {
	typ := TransformationExecutorOutputHeadersTypeStr

	return TransformationExecutorOutputHeaders{
		Str:  &str,
		Type: typ,
	}
}

func CreateTransformationExecutorOutputHeadersMapOfany(mapOfany map[string]interface{}) TransformationExecutorOutputHeaders {
	typ := TransformationExecutorOutputHeadersTypeMapOfany

	return TransformationExecutorOutputHeaders{
		MapOfany: mapOfany,
		Type:     typ,
	}
}

func (u *TransformationExecutorOutputHeaders) UnmarshalJSON(data []byte) error {

	str := ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = TransformationExecutorOutputHeadersTypeStr
		return nil
	}

	mapOfany := map[string]interface{}{}
	if err := utils.UnmarshalJSON(data, &mapOfany, "", true, true); err == nil {
		u.MapOfany = mapOfany
		u.Type = TransformationExecutorOutputHeadersTypeMapOfany
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u TransformationExecutorOutputHeaders) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.MapOfany != nil {
		return utils.MarshalJSON(u.MapOfany, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type TransformationExecutorOutputSchemas2 struct {
}

type TransformationExecutorOutputParsedQueryType string

const (
	TransformationExecutorOutputParsedQueryTypeStr                                  TransformationExecutorOutputParsedQueryType = "str"
	TransformationExecutorOutputParsedQueryTypeTransformationExecutorOutputSchemas2 TransformationExecutorOutputParsedQueryType = "TransformationExecutorOutput_Schemas_2"
)

type TransformationExecutorOutputParsedQuery struct {
	Str                                  *string
	TransformationExecutorOutputSchemas2 *TransformationExecutorOutputSchemas2

	Type TransformationExecutorOutputParsedQueryType
}

func CreateTransformationExecutorOutputParsedQueryStr(str string) TransformationExecutorOutputParsedQuery {
	typ := TransformationExecutorOutputParsedQueryTypeStr

	return TransformationExecutorOutputParsedQuery{
		Str:  &str,
		Type: typ,
	}
}

func CreateTransformationExecutorOutputParsedQueryTransformationExecutorOutputSchemas2(transformationExecutorOutputSchemas2 TransformationExecutorOutputSchemas2) TransformationExecutorOutputParsedQuery {
	typ := TransformationExecutorOutputParsedQueryTypeTransformationExecutorOutputSchemas2

	return TransformationExecutorOutputParsedQuery{
		TransformationExecutorOutputSchemas2: &transformationExecutorOutputSchemas2,
		Type:                                 typ,
	}
}

func (u *TransformationExecutorOutputParsedQuery) UnmarshalJSON(data []byte) error {

	transformationExecutorOutputSchemas2 := TransformationExecutorOutputSchemas2{}
	if err := utils.UnmarshalJSON(data, &transformationExecutorOutputSchemas2, "", true, true); err == nil {
		u.TransformationExecutorOutputSchemas2 = &transformationExecutorOutputSchemas2
		u.Type = TransformationExecutorOutputParsedQueryTypeTransformationExecutorOutputSchemas2
		return nil
	}

	str := ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = TransformationExecutorOutputParsedQueryTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u TransformationExecutorOutputParsedQuery) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.TransformationExecutorOutputSchemas2 != nil {
		return utils.MarshalJSON(u.TransformationExecutorOutputSchemas2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type TransformationExecutorOutput1 struct {
}

type TransformationExecutorOutputQueryType string

const (
	TransformationExecutorOutputQueryTypeTransformationExecutorOutput1 TransformationExecutorOutputQueryType = "TransformationExecutorOutput_1"
	TransformationExecutorOutputQueryTypeStr                           TransformationExecutorOutputQueryType = "str"
)

type TransformationExecutorOutputQuery struct {
	TransformationExecutorOutput1 *TransformationExecutorOutput1
	Str                           *string

	Type TransformationExecutorOutputQueryType
}

func CreateTransformationExecutorOutputQueryTransformationExecutorOutput1(transformationExecutorOutput1 TransformationExecutorOutput1) TransformationExecutorOutputQuery {
	typ := TransformationExecutorOutputQueryTypeTransformationExecutorOutput1

	return TransformationExecutorOutputQuery{
		TransformationExecutorOutput1: &transformationExecutorOutput1,
		Type:                          typ,
	}
}

func CreateTransformationExecutorOutputQueryStr(str string) TransformationExecutorOutputQuery {
	typ := TransformationExecutorOutputQueryTypeStr

	return TransformationExecutorOutputQuery{
		Str:  &str,
		Type: typ,
	}
}

func (u *TransformationExecutorOutputQuery) UnmarshalJSON(data []byte) error {

	transformationExecutorOutput1 := TransformationExecutorOutput1{}
	if err := utils.UnmarshalJSON(data, &transformationExecutorOutput1, "", true, true); err == nil {
		u.TransformationExecutorOutput1 = &transformationExecutorOutput1
		u.Type = TransformationExecutorOutputQueryTypeTransformationExecutorOutput1
		return nil
	}

	str := ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = TransformationExecutorOutputQueryTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u TransformationExecutorOutputQuery) MarshalJSON() ([]byte, error) {
	if u.TransformationExecutorOutput1 != nil {
		return utils.MarshalJSON(u.TransformationExecutorOutput1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type TransformationExecutorOutputRequest struct {
	Body        *TransformationExecutorOutputBody        `json:"body,omitempty"`
	Headers     *TransformationExecutorOutputHeaders     `json:"headers,omitempty"`
	ParsedQuery *TransformationExecutorOutputParsedQuery `json:"parsed_query,omitempty"`
	Path        string                                   `json:"path"`
	Query       *TransformationExecutorOutputQuery       `json:"query,omitempty"`
}

func (o *TransformationExecutorOutputRequest) GetBody() *TransformationExecutorOutputBody {
	if o == nil {
		return nil
	}
	return o.Body
}

func (o *TransformationExecutorOutputRequest) GetHeaders() *TransformationExecutorOutputHeaders {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *TransformationExecutorOutputRequest) GetParsedQuery() *TransformationExecutorOutputParsedQuery {
	if o == nil {
		return nil
	}
	return o.ParsedQuery
}

func (o *TransformationExecutorOutputRequest) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *TransformationExecutorOutputRequest) GetQuery() *TransformationExecutorOutputQuery {
	if o == nil {
		return nil
	}
	return o.Query
}

type TransformationExecutorOutput struct {
	Console     []ConsoleLine `json:"console,omitempty"`
	ExecutionID *string       `json:"execution_id,omitempty"`
	// The minimum log level to open the issue on
	LogLevel         TransformationExecutionLogLevel      `json:"log_level"`
	Request          *TransformationExecutorOutputRequest `json:"request,omitempty"`
	RequestID        *string                              `json:"request_id,omitempty"`
	TransformationID *string                              `json:"transformation_id,omitempty"`
}

func (o *TransformationExecutorOutput) GetConsole() []ConsoleLine {
	if o == nil {
		return nil
	}
	return o.Console
}

func (o *TransformationExecutorOutput) GetExecutionID() *string {
	if o == nil {
		return nil
	}
	return o.ExecutionID
}

func (o *TransformationExecutorOutput) GetLogLevel() TransformationExecutionLogLevel {
	if o == nil {
		return TransformationExecutionLogLevel("")
	}
	return o.LogLevel
}

func (o *TransformationExecutorOutput) GetRequest() *TransformationExecutorOutputRequest {
	if o == nil {
		return nil
	}
	return o.Request
}

func (o *TransformationExecutorOutput) GetRequestID() *string {
	if o == nil {
		return nil
	}
	return o.RequestID
}

func (o *TransformationExecutorOutput) GetTransformationID() *string {
	if o == nil {
		return nil
	}
	return o.TransformationID
}
