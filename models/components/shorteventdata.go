// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package components

import (
	"errors"
	"github.com/speakeasy-sdks/hookdeck-go/v2/internal/utils"
)

type ShortEventData2 struct {
}

type ShortEventDataBodyType string

const (
	ShortEventDataBodyTypeStr             ShortEventDataBodyType = "str"
	ShortEventDataBodyTypeShortEventData2 ShortEventDataBodyType = "ShortEventData_2"
	ShortEventDataBodyTypeArrayOfany      ShortEventDataBodyType = "arrayOfany"
)

type ShortEventDataBody struct {
	Str             *string
	ShortEventData2 *ShortEventData2
	ArrayOfany      []interface{}

	Type ShortEventDataBodyType
}

func CreateShortEventDataBodyStr(str string) ShortEventDataBody {
	typ := ShortEventDataBodyTypeStr

	return ShortEventDataBody{
		Str:  &str,
		Type: typ,
	}
}

func CreateShortEventDataBodyShortEventData2(shortEventData2 ShortEventData2) ShortEventDataBody {
	typ := ShortEventDataBodyTypeShortEventData2

	return ShortEventDataBody{
		ShortEventData2: &shortEventData2,
		Type:            typ,
	}
}

func CreateShortEventDataBodyArrayOfany(arrayOfany []interface{}) ShortEventDataBody {
	typ := ShortEventDataBodyTypeArrayOfany

	return ShortEventDataBody{
		ArrayOfany: arrayOfany,
		Type:       typ,
	}
}

func (u *ShortEventDataBody) UnmarshalJSON(data []byte) error {

	shortEventData2 := ShortEventData2{}
	if err := utils.UnmarshalJSON(data, &shortEventData2, "", true, true); err == nil {
		u.ShortEventData2 = &shortEventData2
		u.Type = ShortEventDataBodyTypeShortEventData2
		return nil
	}

	str := ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ShortEventDataBodyTypeStr
		return nil
	}

	arrayOfany := []interface{}{}
	if err := utils.UnmarshalJSON(data, &arrayOfany, "", true, true); err == nil {
		u.ArrayOfany = arrayOfany
		u.Type = ShortEventDataBodyTypeArrayOfany
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u ShortEventDataBody) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ShortEventData2 != nil {
		return utils.MarshalJSON(u.ShortEventData2, "", true)
	}

	if u.ArrayOfany != nil {
		return utils.MarshalJSON(u.ArrayOfany, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type HeadersType string

const (
	HeadersTypeStr      HeadersType = "str"
	HeadersTypeMapOfstr HeadersType = "mapOfstr"
)

type Headers struct {
	Str      *string
	MapOfstr map[string]string

	Type HeadersType
}

func CreateHeadersStr(str string) Headers {
	typ := HeadersTypeStr

	return Headers{
		Str:  &str,
		Type: typ,
	}
}

func CreateHeadersMapOfstr(mapOfstr map[string]string) Headers {
	typ := HeadersTypeMapOfstr

	return Headers{
		MapOfstr: mapOfstr,
		Type:     typ,
	}
}

func (u *Headers) UnmarshalJSON(data []byte) error {

	str := ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = HeadersTypeStr
		return nil
	}

	mapOfstr := map[string]string{}
	if err := utils.UnmarshalJSON(data, &mapOfstr, "", true, true); err == nil {
		u.MapOfstr = mapOfstr
		u.Type = HeadersTypeMapOfstr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u Headers) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.MapOfstr != nil {
		return utils.MarshalJSON(u.MapOfstr, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type ShortEventDataSchemas2 struct {
}

type ParsedQueryType string

const (
	ParsedQueryTypeStr                    ParsedQueryType = "str"
	ParsedQueryTypeShortEventDataSchemas2 ParsedQueryType = "ShortEventData_Schemas_2"
)

type ParsedQuery struct {
	Str                    *string
	ShortEventDataSchemas2 *ShortEventDataSchemas2

	Type ParsedQueryType
}

func CreateParsedQueryStr(str string) ParsedQuery {
	typ := ParsedQueryTypeStr

	return ParsedQuery{
		Str:  &str,
		Type: typ,
	}
}

func CreateParsedQueryShortEventDataSchemas2(shortEventDataSchemas2 ShortEventDataSchemas2) ParsedQuery {
	typ := ParsedQueryTypeShortEventDataSchemas2

	return ParsedQuery{
		ShortEventDataSchemas2: &shortEventDataSchemas2,
		Type:                   typ,
	}
}

func (u *ParsedQuery) UnmarshalJSON(data []byte) error {

	shortEventDataSchemas2 := ShortEventDataSchemas2{}
	if err := utils.UnmarshalJSON(data, &shortEventDataSchemas2, "", true, true); err == nil {
		u.ShortEventDataSchemas2 = &shortEventDataSchemas2
		u.Type = ParsedQueryTypeShortEventDataSchemas2
		return nil
	}

	str := ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ParsedQueryTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u ParsedQuery) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ShortEventDataSchemas2 != nil {
		return utils.MarshalJSON(u.ShortEventDataSchemas2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type ShortEventData struct {
	Body           *ShortEventDataBody `json:"body,omitempty"`
	Headers        *Headers            `json:"headers,omitempty"`
	IsLargePayload *bool               `json:"is_large_payload,omitempty"`
	ParsedQuery    *ParsedQuery        `json:"parsed_query,omitempty"`
	Path           string              `json:"path"`
	Query          *string             `json:"query,omitempty"`
}

func (o *ShortEventData) GetBody() *ShortEventDataBody {
	if o == nil {
		return nil
	}
	return o.Body
}

func (o *ShortEventData) GetHeaders() *Headers {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *ShortEventData) GetIsLargePayload() *bool {
	if o == nil {
		return nil
	}
	return o.IsLargePayload
}

func (o *ShortEventData) GetParsedQuery() *ParsedQuery {
	if o == nil {
		return nil
	}
	return o.ParsedQuery
}

func (o *ShortEventData) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *ShortEventData) GetQuery() *string {
	if o == nil {
		return nil
	}
	return o.Query
}
